<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETL Automation - Shell Scripting Hub</title>
    <link rel="stylesheet" href="../../assets/css/main.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <header class="header">
        <div class="container header-content">
            <a href="../../index.html" class="logo">
                <svg class="logo-icon" viewBox="0 0 40 40" fill="none">
                    <rect width="40" height="40" rx="8" fill="#e25a1c"/>
                    <path d="M12 20L20 12L28 20L20 28L12 20Z" fill="white"/>
                    <circle cx="20" cy="20" r="4" fill="#e25a1c"/>
                </svg>
                <span>Data Engineering Hub</span>
            </a>
            <nav class="nav">
                <a href="../../index.html#shell" class="nav-link active">Shell</a>
                <button class="theme-toggle">&#127769;</button>
            </nav>
        </div>
    </header>

    <main class="container">
        <section class="section">
            <h1>ETL Automation</h1>
            <p>Automate ETL workflows with shell scripts including scheduling, dependency management, and orchestration patterns.</p>

            <h2>3D Visualization</h2>
            <div id="visualization" class="visualization-container"></div>

            <h2>Code Examples</h2>

            <div class="tabs">
                <button class="tab active" data-tab="scheduler">Job Scheduling</button>
                <button class="tab" data-tab="deps">Dependencies</button>
                <button class="tab" data-tab="parallel">Parallel Processing</button>
                <button class="tab" data-tab="orchestration">Orchestration</button>
            </div>

            <div class="tab-contents">
                <div id="scheduler" class="tab-content active">
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Bash</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <div class="code-block">
<pre>#!/bin/bash
# ============================================
# JOB SCHEDULING WITH CRON
# ============================================

# Cron syntax: minute hour day month weekday command
# * * * * * command
# | | | | |
# | | | | +-- Day of week (0-7, Sun=0 or 7)
# | | | +---- Month (1-12)
# | | +------ Day of month (1-31)
# | +-------- Hour (0-23)
# +---------- Minute (0-59)

# Examples:
# 0 * * * *     - Every hour
# 0 0 * * *     - Daily at midnight
# 0 0 * * 0     - Weekly on Sunday
# 0 0 1 * *     - Monthly on 1st
# */15 * * * *  - Every 15 minutes
# 0 9-17 * * 1-5 - Hourly 9am-5pm weekdays

# Install cron job programmatically
install_cron_job() {
    local schedule="$1"
    local command="$2"
    local job_name="$3"
    
    # Remove existing job with same name
    crontab -l 2>/dev/null | grep -v "# $job_name" | crontab -
    
    # Add new job
    (crontab -l 2>/dev/null; echo "$schedule $command # $job_name") | crontab -
    
    echo "Installed cron job: $job_name"
}

# List cron jobs
list_cron_jobs() {
    echo "Current cron jobs:"
    crontab -l 2>/dev/null || echo "No cron jobs"
}

# Remove cron job
remove_cron_job() {
    local job_name="$1"
    crontab -l 2>/dev/null | grep -v "# $job_name" | crontab -
    echo "Removed cron job: $job_name"
}

# Wrapper script for cron jobs
# /usr/local/bin/etl_wrapper.sh
cat << 'WRAPPER' > /tmp/etl_wrapper.sh
#!/bin/bash
set -euo pipefail

JOB_NAME="$1"
SCRIPT="$2"
LOG_DIR="/var/log/etl"
LOCK_DIR="/var/lock/etl"

mkdir -p "$LOG_DIR" "$LOCK_DIR"

LOG_FILE="$LOG_DIR/${JOB_NAME}_$(date +%Y%m%d).log"
LOCK_FILE="$LOCK_DIR/${JOB_NAME}.lock"

# Prevent concurrent runs
exec 200>"$LOCK_FILE"
if ! flock -n 200; then
    echo "Job $JOB_NAME already running" >> "$LOG_FILE"
    exit 1
fi

# Run with logging
{
    echo "=== Started: $(date) ==="
    "$SCRIPT"
    echo "=== Completed: $(date) ==="
} >> "$LOG_FILE" 2>&1
WRAPPER</pre>
                        </div>
                    </div>
                </div>

                <div id="deps" class="tab-content">
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Bash</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <div class="code-block">
<pre>#!/bin/bash
# ============================================
# DEPENDENCY MANAGEMENT
# ============================================

# Check if dependency job completed
check_dependency() {
    local job_name="$1"
    local date="${2:-$(date +%Y-%m-%d)}"
    local marker_file="/var/run/etl/${job_name}_${date}.done"
    
    if [ -f "$marker_file" ]; then
        return 0
    else
        return 1
    fi
}

# Wait for dependency with timeout
wait_for_dependency() {
    local job_name="$1"
    local timeout_minutes="${2:-60}"
    local check_interval="${3:-60}"
    
    local elapsed=0
    local max_seconds=$((timeout_minutes * 60))
    
    echo "Waiting for $job_name..."
    
    while ! check_dependency "$job_name"; do
        if [ $elapsed -ge $max_seconds ]; then
            echo "Timeout waiting for $job_name" >&2
            return 1
        fi
        
        sleep $check_interval
        elapsed=$((elapsed + check_interval))
        echo "  Still waiting... ($elapsed seconds)"
    done
    
    echo "$job_name completed"
    return 0
}

# Mark job as complete
mark_complete() {
    local job_name="$1"
    local date="${2:-$(date +%Y-%m-%d)}"
    local marker_dir="/var/run/etl"
    
    mkdir -p "$marker_dir"
    touch "${marker_dir}/${job_name}_${date}.done"
}

# Job with dependencies
run_with_dependencies() {
    local job_name="$1"
    shift
    local dependencies=("$@")
    
    echo "Job: $job_name"
    echo "Dependencies: ${dependencies[*]}"
    
    # Wait for all dependencies
    for dep in "${dependencies[@]}"; do
        if ! wait_for_dependency "$dep" 120; then
            echo "Failed: dependency $dep not met" >&2
            return 1
        fi
    done
    
    echo "All dependencies met, running $job_name"
    # Run actual job here
    
    mark_complete "$job_name"
}

# Example usage
# run_with_dependencies "load_fact_sales" "extract_orders" "extract_products"</pre>
                        </div>
                    </div>
                </div>

                <div id="parallel" class="tab-content">
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Bash</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <div class="code-block">
<pre>#!/bin/bash
# ============================================
# PARALLEL PROCESSING
# ============================================

# Process files in parallel with xargs
process_files_parallel() {
    local input_dir="$1"
    local max_jobs="${2:-4}"
    
    find "$input_dir" -name "*.csv" | \
        xargs -P "$max_jobs" -I {} bash -c 'process_single_file "$@"' _ {}
}

# GNU Parallel (if available)
process_with_gnu_parallel() {
    local input_dir="$1"
    
    find "$input_dir" -name "*.csv" | \
        parallel -j 4 --progress process_single_file {}
}

# Background jobs with job control
run_parallel_jobs() {
    local pids=()
    
    # Start background jobs
    job1 &
    pids+=($!)
    
    job2 &
    pids+=($!)
    
    job3 &
    pids+=($!)
    
    # Wait for all jobs
    local failed=0
    for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
            echo "Job $pid failed" >&2
            ((failed++))
        fi
    done
    
    return $failed
}

# Parallel with max concurrency
run_with_max_concurrency() {
    local max_jobs="$1"
    shift
    local commands=("$@")
    
    local running=0
    local pids=()
    
    for cmd in "${commands[@]}"; do
        # Wait if at max concurrency
        while [ $running -ge $max_jobs ]; do
            for i in "${!pids[@]}"; do
                if ! kill -0 "${pids[$i]}" 2>/dev/null; then
                    wait "${pids[$i]}"
                    unset 'pids[$i]'
                    ((running--))
                fi
            done
            sleep 1
        done
        
        # Start new job
        eval "$cmd" &
        pids+=($!)
        ((running++))
    done
    
    # Wait for remaining jobs
    wait
}

# Parallel processing with results collection
parallel_with_results() {
    local result_dir=$(mktemp -d)
    local pids=()
    
    for i in {1..5}; do
        (
            # Process and save result
            result=$(process_item "$i")
            echo "$result" > "$result_dir/result_$i.txt"
        ) &
        pids+=($!)
    done
    
    wait
    
    # Collect results
    cat "$result_dir"/result_*.txt
    rm -rf "$result_dir"
}</pre>
                        </div>
                    </div>
                </div>

                <div id="orchestration" class="tab-content">
                    <div class="code-container">
                        <div class="code-header">
                            <span class="code-language">Bash</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <div class="code-block">
<pre>#!/bin/bash
# ============================================
# ETL ORCHESTRATION FRAMEWORK
# ============================================
set -euo pipefail

# Configuration
declare -A JOB_STATUS
declare -A JOB_DEPS
LOG_DIR="/var/log/etl"
STATE_FILE="/var/run/etl/state.json"

# Define jobs and dependencies
define_workflow() {
    JOB_DEPS[extract_customers]=""
    JOB_DEPS[extract_products]=""
    JOB_DEPS[extract_orders]=""
    JOB_DEPS[transform_customers]="extract_customers"
    JOB_DEPS[transform_products]="extract_products"
    JOB_DEPS[transform_orders]="extract_orders"
    JOB_DEPS[load_dimensions]="transform_customers transform_products"
    JOB_DEPS[load_facts]="transform_orders load_dimensions"
    JOB_DEPS[build_aggregates]="load_facts"
}

# Check if job can run
can_run() {
    local job="$1"
    local deps="${JOB_DEPS[$job]}"
    
    if [ -z "$deps" ]; then
        return 0
    fi
    
    for dep in $deps; do
        if [ "${JOB_STATUS[$dep]:-pending}" != "completed" ]; then
            return 1
        fi
    done
    
    return 0
}

# Run single job
run_job() {
    local job="$1"
    local log_file="$LOG_DIR/${job}_$(date +%Y%m%d_%H%M%S).log"
    
    echo "Running: $job"
    JOB_STATUS[$job]="running"
    
    if "./$job.sh" > "$log_file" 2>&1; then
        JOB_STATUS[$job]="completed"
        echo "  Completed: $job"
        return 0
    else
        JOB_STATUS[$job]="failed"
        echo "  Failed: $job (see $log_file)"
        return 1
    fi
}

# Run workflow
run_workflow() {
    define_workflow
    
    local all_jobs="${!JOB_DEPS[@]}"
    local completed=0
    local total=${#JOB_DEPS[@]}
    local failed=0
    
    echo "Starting workflow with $total jobs"
    
    while [ $completed -lt $total ] && [ $failed -eq 0 ]; do
        local ran_something=false
        
        for job in $all_jobs; do
            local status="${JOB_STATUS[$job]:-pending}"
            
            if [ "$status" = "pending" ] && can_run "$job"; then
                if run_job "$job"; then
                    ((completed++))
                else
                    ((failed++))
                fi
                ran_something=true
            fi
        done
        
        if ! $ran_something && [ $completed -lt $total ]; then
            echo "Deadlock detected!" >&2
            return 1
        fi
    done
    
    if [ $failed -gt 0 ]; then
        echo "Workflow failed"
        return 1
    fi
    
    echo "Workflow completed successfully"
}

run_workflow</pre>
                        </div>
                    </div>
                </div>
            </div>

            <div style="display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
                <a href="../07_data_pipeline_scripts/index.html" style="color: var(--text-muted);">&larr; Previous: Data Pipeline Scripts</a>
                <a href="../09_log_processing/index.html" style="color: var(--accent-primary);">Next: Log Processing &rarr;</a>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="container footer-content">
            <p style="margin: 0; color: var(--text-muted);">PySpark & Data Engineering Learning Hub</p>
        </div>
    </footer>

    <script src="../../assets/js/main.js"></script>
    <script src="../../assets/js/visualization.js"></script>
    <script>
        let viz;
        document.addEventListener('DOMContentLoaded', function() {
            viz = new DataVisualization('visualization', {
                backgroundColor: document.documentElement.getAttribute('data-theme') === 'dark' ? 0x1a1a2e : 0xf8f9fa,
                cameraPosition: { x: 6, y: 4, z: 6 }
            });
            
            // Workflow DAG visualization
            viz.createDataNode({ type: 'sphere', size: 0.4, color: 0x4dabf7, position: { x: -2, y: 1, z: 0 } });
            viz.createLabel('Extract', { x: -2, y: 1.7, z: 0 });
            
            viz.createDataNode({ type: 'sphere', size: 0.4, color: 0xe25a1c, position: { x: 0, y: 1, z: -1 } });
            viz.createDataNode({ type: 'sphere', size: 0.4, color: 0xe25a1c, position: { x: 0, y: 1, z: 1 } });
            viz.createLabel('Transform', { x: 0, y: 1.7, z: 0 });
            
            viz.createDataNode({ type: 'sphere', size: 0.4, color: 0x198754, position: { x: 2, y: 1, z: 0 } });
            viz.createLabel('Load', { x: 2, y: 1.7, z: 0 });
            
            viz.createArrow({ x: -1.5, y: 1, z: 0 }, { x: -0.5, y: 1, z: -0.8 }, { color: 0x888888 });
            viz.createArrow({ x: -1.5, y: 1, z: 0 }, { x: -0.5, y: 1, z: 0.8 }, { color: 0x888888 });
            viz.createArrow({ x: 0.5, y: 1, z: -0.8 }, { x: 1.5, y: 1, z: 0 }, { color: 0x888888 });
            viz.createArrow({ x: 0.5, y: 1, z: 0.8 }, { x: 1.5, y: 1, z: 0 }, { color: 0x888888 });
            
            viz.createLabel('ETL Workflow DAG', { x: 0, y: -0.5, z: 0 });
            viz.createGrid(10, 10);
        });
    </script>
</body>
</html>
